<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="cmake-doc" kind="page">
    <compoundname>cmake-doc</compoundname>
    <title>cmake doc</title>
    <briefdescription>
<para>Guide how to cmake. </para>
    </briefdescription>
    <detaileddescription>
<para>Guide how to cmake.</para>
<para>查看是否安装了CMake及版本号，可通过执行一下语句来验证：</para>
<para><programlisting filename=".sh"><codeline><highlight class="normal">cmake<sp/>--version</highlight></codeline>
</programlisting></para>
<para>若没有安装，可执行以下语句进行安装：</para>
<para><programlisting filename=".sh"><codeline><highlight class="normal">sudo<sp/>apt-get<sp/>install<sp/>cmake</highlight></codeline>
</programlisting></para>
<para>CMakeLists.txt的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的，参数和变量是大小写相关的，但，推荐全部使用大写指令。符号”#”后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格或分号进行间隔。变量使用${xxx}引用。</para>
<para><hruler/>
</para>
<sect1 id="cmake-doc_1常用命令说明">
<title>常用命令说明</title>
<para><orderedlist>
<listitem><para>aux_source_directory(&lt;dir&gt;&lt;variable&gt;) :该命令会把参数&lt;dir&gt;中所有的源文件(不包括头文件)名称赋值给参数&lt;variable&gt;；</para>
</listitem><listitem><para>find_path(&lt;VAR&gt; name1[path1 path2 …]):该命令在参数path*指示的目录中查找文件name1并将查找到的路径保存在变量VAR中(其中使用”[…]”包含的项表示可忽略项，使用”…|…”分割的项表示只能选择其中一项)；</para>
</listitem><listitem><para>find_library(${var} NAMES name1[name2 …] PATHS path1 [path2 …] PATH_SUFFIXES suffix1 [uffix2 …]):搜索一个外部的链接库文件,并将结果的全部路径保存到var变量中。要搜索的链接库文件名字可能是name1,name2等；搜索路径为path1, path2等；此外还可以指定路径的后缀词为suffix1,suffix2等；</para>
</listitem><listitem><para>find_package(name):在指定的模块目录中搜索一个名为Find&lt;name&gt;.cmake(例如，FindOSG.cmake)的CMake脚本模块文件，执行其中的内容，意图搜索到指定的外部依赖库头文件和库文件位置；</para>
</listitem><listitem><para>find_program:搜索一个外部的可执行程序；</para>
</listitem><listitem><para>project(name):指定项目名称name；</para>
</listitem><listitem><para>include(file):在当前文件中包含另一个CMake脚本文件的内容,用来载入CMakeLists.txt文件，也用于载入预定义的cmake模块；</para>
</listitem><listitem><para>include_directories:指定头文件的搜索路径，用来向工程添加多个特定的头文件搜索路径，可以多次调用以设置多个路径，相当于指定gcc的-I参数；</para>
</listitem><listitem><para>link_directories:添加非标准的共享库搜索路径，设置外部动态链接库或静态链接库的搜素路径，相当于gcc的-L参数；</para>
</listitem><listitem><para>link_libraries:添加链接库；</para>
</listitem><listitem><para>add_subdirectory:用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制文件存放的位置；</para>
</listitem><listitem><para>add_executable:编译可执行程序，指定编译，好像也可以添加.o文件；</para>
</listitem><listitem><para>add_definitions(-DMACRO1-DMACRO2 …):添加编译参数，添加-D预编译宏定义，可以一次添加多个；</para>
</listitem><listitem><para>add_dependencies:定义target依赖的其它target，确保在编译本target之前，其它的target已经被构建；</para>
</listitem><listitem><para>add_library:可以设置要生成的链接库为SHARED或者STATIC，还可以设置MODULE(插件，可动态调用，但不作为其它工程的依赖)；</para>
</listitem><listitem><para>add_custom_target(name COMMANDcmd1 [COMMAND cmd2 ..]):添加一个名为name的编译目录，并指定一个或多个自定义的命令cmd1,cmd2等；注意ADD_CUSTOM_COMMAND与这个命令的区别：前者是针对一个已有的子工程进行自定义编译规则的设置；后者则是建立一个新的自定义的目标工程；</para>
</listitem><listitem><para>target_link_libraries:可以用来为target添加需要链接的共享库，指定工程所用的依赖库，添加链接库，添加动态库或静态库，相当于指定-l参数；</para>
</listitem><listitem><para>message:打印消息，在控制台或者对话框输出一行或多行调试信息；</para>
</listitem><listitem><para>set:定义一个用户自定义变量；</para>
</listitem><listitem><para>set_target_properties:用来设置输出的名称，对于动态库，还可以用来指定动态库版本和API版本；</para>
</listitem><listitem><para>cmake_minimum_required:设定依赖的cmake版本；</para>
</listitem><listitem><para>configure_file(infile outfile):将文件infile复制到outfile的位置，同时执行其中变量的自动配置和更替;</para>
</listitem><listitem><para>install:安装目标工程到指定的文件夹,此命令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等；</para>
</listitem><listitem><para>option(${var} “text” value):向用户提供一个可选项，提示信息为text，初始值为value，并将最终的结果传递到var变量中；</para>
</listitem><listitem><para>enable_testing:用来控制Makefile是否构建test目标，涉及工程所有目录；</para>
</listitem><listitem><para>exec_program:用于在指定的目录运行某个程序；</para>
</listitem><listitem><para>execute_process:执行一个或多个子进程，按指定的先后顺序运行一个或多个命令；</para>
</listitem><listitem><para>file:文件操作命令；</para>
</listitem></orderedlist>
</para>
<para><hruler/>
</para>
</sect1>
<sect1 id="cmake-doc_1内置变量、环境变量">
<title>内置变量、环境变量</title>
<para><orderedlist>
<listitem><para>CMAKE_C_COMPILER:指定C编译器；</para>
</listitem><listitem><para>CMAKE_CXX_COMPILER:指定C++编译器；</para>
</listitem><listitem><para>CMAKE_C_FLAGS:指定编译C文件时的编译选项，如-g，也可以通过add_definitions添加编译选项；</para>
</listitem><listitem><para>CMAKE_CXX_FLAGS:设置C++编译选项；</para>
</listitem><listitem><para>CMAKE_BUILD_TYPE:build类型(Debug,Release,…),CMAKE_BUILD_TYPE=Debug；</para>
</listitem><listitem><para>CMAKE_COMMAND:也就是CMake可执行文件本身的全路径；</para>
</listitem><listitem><para>CMAKE_DEBUG_POSTFIX:Debug版本生成目标的后缀，通常可以设置为”d”字符；</para>
</listitem><listitem><para>CMAKE_GENERATOR:编译器名称，例如”UnixMakefiles”，“Visual Studio 7”等；</para>
</listitem><listitem><para>CMAKE_INSTALL_PREFIX:工程安装目录，所有生成和调用所需的可执行程序，库文件，头文件都会安装到该路径下，Unix/Linux下默认为/usr/local, windows下默认为C:\Program Files；</para>
</listitem><listitem><para>CMAKE_MODULE_PATH:设置搜索CMakeModules模块(.cmake)的额外路径，用来定义自己的cmake模块所在的路径；</para>
</listitem><listitem><para>CMAKE_CURRENT_SOURCE_DIR:指的是当前处理的CMakeLists.txt所在的路径；</para>
</listitem><listitem><para>CMAKE_CURRENT_BINARY_DIR:如果是in-source编译，则跟CMAKE_CURRENT_SOURCE_DIR一致；如果是out-of-source，指的是target编译目录；</para>
</listitem><listitem><para>CMAKE_CURRENT_LIST_FILE:输出调用这个变量的CMakeLists.txt的完整路径；</para>
</listitem><listitem><para>CMAKE_CURRENT_LIST_LINE:输出这个变量所在的行；</para>
</listitem><listitem><para>CMAKE_INCLUDE_CURRENT_DIR:自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCE_DIR到当前处理的CMakeLists.txt；</para>
</listitem><listitem><para>CMAKE_INCLUDE_DIRECTORIES_PROJECT_EFORE:将工程提供的头文件目录始终至于系统头文件目录的前面，当你定义的头文件确定跟系统发生冲突时可以提供一些帮助；</para>
</listitem><listitem><para>EXECUTABLE_OUTPUT_PATH:指定可执行文件的存放路径，最终结果的存放目录；</para>
</listitem><listitem><para>LIBRARY_OUTPUT_PATH:指定库文件存放路径，最终结果的存放目录；</para>
</listitem><listitem><para>BUILD_SHARED_LIBS:指定编译成静态库还是动态库；</para>
</listitem><listitem><para>PROJECT_BINARY_DIR(CMAKE_BINARY_DIR):如果是内部构建(in-sourcebuild)，指的就是工程顶层目录；如果是外部构建(out-of-source build)，指的是工程编译发生的目录；</para>
</listitem><listitem><para>PROJECT_NAME:工程名称，即使用PROJECT命令设置的名称；</para>
</listitem><listitem><para>PROJECT_SOURCE_DIR(CMAKE_SOURCE_DIR):工程源代码文件所在的目录，指的是工程顶层目录；</para>
</listitem><listitem><para>CYGWIN:标识当前系统是否为Cygwin；</para>
</listitem><listitem><para>MSVC:标识当前系统是否使用MicrosoftVisual C；</para>
</listitem><listitem><para>UNIX:标识当前系统是否为Unix系列(包括Linux、Cygwin和Apple)；</para>
</listitem><listitem><para>WIN32:标识当前系统是否为Windows及Win64；</para>
</listitem></orderedlist>
</para>
<para><hruler/>
</para>
</sect1>
<sect1 id="cmake-doc_1内置变量的使用">
<title>内置变量的使用</title>
<para><orderedlist>
<listitem><para>在CMakeLists.txt中指定，使用set；</para>
</listitem><listitem><para>cmake命令中使用，如cmake-DBUILD_SHARED_LIBS=OFF；</para>
</listitem></orderedlist>
</para>
<para><hruler/>
</para>
<para>CMake调用环境变量的方式：使用$ENV{NAME}指令就可以调用系统的环境变量了。如MESSAGE(STATUS “HOME dir: $ENV {HOME}”)</para>
<para>设置环境变量的方式是：SET(ENV{变量名} 值)</para>
<para>变量，以${MY_VAIRABLE}的形式表达，其储存类型为字符串类型，但是可以根据具体命令的要求自动转换成布尔型、整型或者浮点类型。变量可以出现在字符串中，也可以实现”内省”。变量有用户自定义和系统内置两种，用户自定义变量使用SET命令设置；而系统变量由系统自动赋值，例如${PROJECT_SOURCE_DIR}。</para>
<para>CMake中的条件语句：IF(expression)… ELSE(expression) … ENDIF(expression) 或者IF(expression1) …ELSEIF(expression2) … ELSE() … ENDIF() ，expression是判断条件，和C/C++类似，CMake的条件也存在”与/或/非”以及”等于/大于/小于”等几种操作符，分别用AND/OR/NOT以及EQUAL/LESS/GREATER来表示。IF控制语句，变量是直接使用变量名引用，而不需要${}。</para>
<para>CMake中的循环语句：FOREACH(vararg1 arg2 …) … ENDFOREACH(var) ，设置一个循环的局部变量var，每次将其赋为arg1，arg2等变量(或者变量数组)中的一个值，并执行循环中的命令段。</para>
<para>CMake中的宏函数可以理解为C语言的函数，它改变代码执行跳转的流程并简化了脚本程序的开发：MACRO(funcname [arg1 [arg2 …]]) … ENDMACRO(funcname) ，和函数的编写要求一样，CMake的宏函数必须制定一个函数名funcname，以及零个或多个输入参数arg1，arg2等。需要调用宏函数的时候，只要直接使用funcname(arg1 arg2)的形式就可以了。</para>
<para>CMake第一次运行的时候，它将产生一个文件叫CMakeCache.txt，该文件可以被看作一个配置文件，它里面的内容就像传递给configure命令的参数集。 </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
